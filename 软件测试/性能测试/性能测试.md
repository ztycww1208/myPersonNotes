# 性能测试

## 1 性能测试的介绍

### 1.1 性能测试的定义

> `定义`：性能测试是通过自动化测试工具，模拟多种正常，峰值以及异常条件，测试系统各项性能指标
>
> `自动化测试工具`：提高效率，节约成本，提高测试的准确性 
>
> `正常，峰值，异常负载`：正常情况下软件的运行是没有问题的，那么异常情况和峰值情况下，软件的运行是否正常，也是需要测试的. 
>
> `性能指标`：比如CPU，内存，吞吐量，响应时间，磁盘I/O，网络I/O等.

### 1.2 性能测试的目的

> `1  评估系统的能力
> 2  测试系统的可靠性
> 3  识别系统的缺陷
> 4  进行性能优化`

### 1.3 性能测试分类/归属

> 1. 按照阶段划分---系统测试 
> 2. 按照技术划分---黑盒测试
> 3. 按照质量划分---`效率(时间，资源)`

### 1.4 性能测试时间-什么时候开始

> 功能测试之后，验收测试之前 或者说 SIT测试之后
>
> 功能稳定之后，具体时间就是没有其他干扰性能环境的时间。比如，一共三轮测试，第二轮测试结束后

## 2 性能测试的策略/方法

### 2.1 负载测试

> `定义`：逐步给服务器施加压力，直到某项数据不达标，测试软件的瓶颈，为性能调优提供数据
> `目的`：测试软件在不同工作量条件下，性能表现情况

### 2.2 压力测试

> `定义`：通过高负载的手段，使服务器资源处于极限，直到某项数据失效，测试软件的极限
> `目的`：通过高负载，可以更快发现软件内存泄漏和稳定性问题

> `内存泄漏`：系统把一定的内存分配个程序，但系统却收不回完整的内存
>
> `内存溢出`：程序需要的内存，系统的内存不够

### 2.3 并发测试

> `定义`：并发测试可以理解为很多用户按照预定的场景，请求某个业务或者功能时是否会出现并发问题. 
>
> `目的`：发现系统中可能存在的并发问题，比如内存泄露，资源争用等.
>
> 
>
> `并发`：同一时刻或者同一时间，对服务器产生压力或者负载 
>
> 
>
> `相对并发`：客户端发送的请求不完全相同(比如：100个用户同时使用微信发送红包，100个用户同时使用微信语音通话) 
> `绝对并发`：客户端发送的请求完全相同 (比如200个用户同时使用QQ视频)



### 2.4 稳定性测试

> `定义`：一般使用目标负载的1.5-2倍的负载数量或者CPU达到70%，测试系统长时间运行，观察系统的稳定性，一般是7*24  小 时。
>
> `目的`：验证系统是否支持长期稳定的运行。该方法需要在压力下持续运行一段时间，测试过程中观察系统指标情况，查看指 标是否有明显变化。

### 2.5 配置测试

> `定义`：通过调整系统软件和硬件环境，了解在不同环境下系统性能指标情况，从而找到系统的最优配置。
>
> `目的`：主要了解各种不同因素对系统性能影响程度，从而判断出最值得进行的调优操作，一般是在对系统性能状况有初步了 解之后进行的。

### 2.6 失效恢复性测试

> `定义`：失效恢复性测试重点关注出现问题以后能否根据现有制定的策略恢复，且恢复后能否正常工作。
>
> `目的`：验证局部故障下系统能否继续使用。

### 2.7 容量测试

> `定义`：测试系统最多能够承受多少用户的访问。



## 3 性能测试术语

### 3.1 场景

> `定义`：模拟用户的真实操作的过程，就叫做场景. 
>
> `单一场景`：模拟用户的单个操作过程，比如登录 
> `混合场景`：模拟用户的多个操作过程，比如：登录--选购---加入购物车

### 3.2 事务

> `定义`：某一个任务从开始到结束的过程。也就是从客户端发送请求开始，到服务器给出响应数据为止的过程，称之为事务

### 3.3 响应时间

> `定义`：某个事务完成的时间，即从客户端发送请求，到接收到服务器响应数据的时间叫做响应时间. 
>
> `响应时间组成：S= 网络传输时间 +web服务器处理时间 + DB服务器处理时间 +waste时间(浏览器处理时间+渲染时间 等) `
>
> 响应时间满足`258原则`： 
> S<=2s 优秀 
> 2s<S<=5s 良好 
> 5s<S<=8s 一般 
> S>8s Bug

### 3.4 并发数

> `定义`：`同一时刻操作的用户数`，或者某一时刻同时向系统提交请求的用户数，提交的请求可能是同一个场景或者功能，也可 能不是同一场景或者功能. 
>
> `狭义并发`：不同用户，同一时刻，对同一服务器，做同一操作，也称为绝对并发. 
> `广义并发`：不同用户，同一时刻，对同一服务器，做不同操作，也称为相对并发.

### 3.5 吞吐量（TPS/QPS）

> `定义`：`服务器每秒处理的事务数或请求数`。从业务角度讲，也可以用每秒请求数或每秒事务数，每秒页面数或每秒查询数等单位来衡量。----也就是服务器每秒的处理能力
>
> QPS：每秒查询数，是指一台服务器每秒能响应的查询数
> TPS：每秒事务数
>
> QPS与TPS的关系：
> 对于一个页面的一次访问，形成一个TPS.但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求就可以计入 QPS.
>
> 
>
> 吞吐量与并发数的关系： 
>
> `吞吐量=并发数/平均响应时间`

### 3.6 思考时间

> 定义：`真实的操作场景中`，用户的每个操作之间会有一个时间间隔，这个时间就叫做思考时间. 
>
> `在脚本中`就是脚本之间的时间间隔.

## 4 性能测试工具

> 
>
> | 工具         | 介绍                                                         |
> | ------------ | ------------------------------------------------------------ |
> | `LoadRunner` | 商业收费性能工具、mercury公司研发，后期被惠普公司收购，价格昂贵160W左右，安装复杂 |
> | `Jmeter`     | 1.免费、开源 <br />2.支持二次开发：现有的软件上进行定制修改，功能的扩展，然后达到自己想要的功能<br />3. 一般来说都不会 改变原有系统的内核<br />4.支持命令行模式运行(非界面)<br />5.支持接口测试 |
> | `soapui`     | 主要做接口测试，极少做性能测试                               |
> | `ab`         | Apache Benchmark的缩写,是apache自带的一个性能测试工具(压力测试),优点是使用方便，统计 功能强大。 |
>
> 

## 5 安装Jmeter

> 1.安装java，配置环境变量：C：\Program Files\Java\jdk1.8.0_131\bin;C：\Program 
>
> Files\Java\jre1.8.0_131\bin; 
>
> 2.验证java的环境变量配置是否ok 
>
> 验证方法：win + r ---cmd ---javac 或者java -version(查看java版本) 
>
> 3.找到jmeter的安装包，解压安装包 
>
> 4.找到bin目录里面的jmeter.bat，双击启动

## 6 Jmeter组件的认识

### 6.1 jmeter的原理

> `原理`：`使用取样器向服务器发送请求，并获取响应数据.并且通过多线程模拟对服务器的压力`. 
>
> jmeter可以作为web服务器与浏览器直接的代理网关，以便捕获浏览器的请求和web服务器的响应，如此就可以很容易地生成性能测试脚本。有了性能测试脚本，jmeter就可以通过线程来模拟真实用户对web服务器的访问压力. 

### 6.2 测试计划

> 可以理解为一个脚本的开始，或者说是一个场景.所有的线程都挂在测试计划的下面. 

### 6.3 线程组

> `作用`：模拟并发数.一个线程就代表一个并发数，线程数多少，就代表并发数多少. 
>
> `位置`：测试计划--右键--添加 --线程---线程组 
>
> `线程组内容`： 
>
> 1.线程数：也就是并发数 
>
> 2.ramp-up时间：启动线程需要的准备时间 
>
> 3.循环次数：如果填写具体数字，代表具体循环几次，如果勾选永远，则会一直执行，直到手动停止. 
>
> 4.调度器--勾选以后可以设置持续运行时间

### 6.4 http取样器

> `作用`：模拟用户向服务器发送请求 
>
> 位置：线程组--添加--取样器--http 请求 
>
> `http 请求的内容：` 
>
> `1.web服务器内容`： 
>
> -协议：发送请求使用的协议，比如 http 或者https 
>
> -服务器名称或IP：请求的目标服务器名称或者IP地址 
>
> -端口号：对应的端口号 
>
> `2.http请求内容： `
>
> -方法：发送请求使用的方法，比如get 或post 
>
> -路径：访问的目标服务器的具体路径，除开ip地址的部分 
>
> -内容编码：定义使用的编码格式，一般是utf-8 
>
> URL的组成：协议 +ip + 端口 +路径

### 6.5 监听器-查看结果树

> `作用`：用来展示取样器执行结果的. 
>
> 
>
> 1.察看结果的方式： 
>
> 1.text 文本方式 
>
> 2.html 网页方式 
>
> 
>
> 2.如何判断取样器执行结果 
>
> -1.红色：代表执行失败 
>
> -2.绿色：代表执行成功 
>
> 
>
> 3.查看结果树内容 
>
> 1.`取样器结果`：主要察看响应代码和响应信息 ，初步判断取样器执行结果 
>
> 2.`请求`： 
>
> --请求体：可察看到请求方法，URL，请求数据，cookie 
>
> --请求头：可察看到域名 
>
> 3.`响应数据`： 
>
> --响应体：以html网页查看更直观，如果出现报错，可以更好查看报错内容 
>
> --响应头：可以察看请求协议以及版本，响应代码，响应信息 
>
> 
>
> `备注`：解决相应数据乱码的方法：线程组---->后置处理器---->bean shell postprocessor----->输入： 
>
> `prev.setDataEncoding("utf-8"); `

### 6.6 监听器-聚合报告

> `作用`:用来展示性能测试结果数据的.可以展示性能指标数据 
>
> `内容`: 
>
> --label:取样器的名字**6.7** 断言**--**响应断言
>
> --samples:发送的请求的数量,跟线程组中线程数和循环次数有关 
>
> 
>
> --average:平均响应时间,单位是毫秒 
>
> --median:50%用户的响应时间,单位是毫秒 
>
> --90%Line:90%用户的响应时间,单位是毫秒 
>
> --95%Line:95%用户的响应时间,单位是毫秒 
>
> --99%Line:99%用户的响应时间,单位是毫秒 
>
> 
>
> --min :最小响应时间 
>
> --最大值:最大响应时间 
>
> 
>
> --Error%:错误率 =失败的请求数/总的请求数 
>
> --Throughput:吞吐量,默认情况下表示每秒完成的请求数 =请求数/总的时间 
>
> 
>
> --Received kb/sec:每秒从服务器接收的数据量 
>
> --Sent KB/sec:每秒向服务器发送的数据量 
>
> 
>
> 备注:聚合报告的数据是可以累加的 

### 6.7 断言-响应断言

> `作用`:用来比较预期结果和实际结果是否一致.就是判断取样器的响应数据中是否有我们想要的数据(预期结果).如果有, 说明测试通过,如果没有,就说明测试不通过. 
>
> `响应断言的内容: `
>
> `1.测试字段`:`取验证信息的方式`---也就是从哪里获取实际结果,与预期结果进行比对 
>
> --`响应文本`:默认响应文本的内容,比如body 
>
> --`响应代码`:响应状态码,比如200表示成功 
>
> --`响应信息`:比如 404 Not Found 
>
> --`response Headers`:响应头 
>
> --`request headers`:请求头 
>
> --`URL 样本`:匹配URL链接 
>
> --`Document(text)`:支持所有的文本(pdf/word文档),比较消耗内存,一般不使用 
>
> --`忽略状态`:jmeter会默认把4或者5开头的响应判断为失败,但如果要进行异常测试,需要用到4或者5开头的响应,为了 
>
> 脚本执行成功,会选择忽略状态. 
>
> --request data:请求数据 
>
> `2.模式匹配规则`:`预期结果和实际结果的比对方式 `
>
> --`包括:`包含,可以使用正则表达式 
>
> --`匹配`:匹配,可以使用正则表达式,表达式必须完全匹配返回结果,要求一致 
>
> --`Equals`:预期结果和实际结果完全一致,不能使用正则 
>
> --`Substring`:与包含差不多,但不能使用正则表达式 
>
> --`否`:取反的意思,要求断言信息不包含要测试的内容 
>
> --`或者`:或的意思,两者中取一个就可以了 

### 6.8 固定定时器

> `作用`:模拟用户真实操作之间的时间间隔 
>
> `位置`:线程组--添加--定时器--固定定时器

## 7 性能测试流程

> 业务学习 
>
> 需求分析:主要分析哪些功能需要做性能测试,明确性能测试的准则 
>
> 模型设计:也就是场景设计,即明确 测试类型,目标并发数,起始并发数,步长 
>
> 编写性能测试计划 
>
> 编写性能测试用例 
>
> 
>
> 测试环境准备 
>
> 测试数据准备 
>
> 脚本开发 
>
> 测试执行 
>
> 缺陷管理 
>
> 
>
> 性能分析 
>
> 性能调优 
>
> 测试报告 

## 8 Jmeter操作

### 8.1 Jmeter脚本编写步骤

> 1.在测试计划下添加线程组 
>
> 2.添加取样器,配置取样器内容 
>
> 3.添加监听器-察看结果树 
>
> 4.添加监听器-聚合报告 
>
> 5.添加断言-响应断言

### 8.2 Jmeter第一个脚本，以ecshop为例

> 1.在页面注册,通过fiddler抓包,找到注册的url和参数 
>
> 2.添加测试计划-线程组-取样器 
>
> 3.配置取样器,在取样器的页面填写抓取到的URL 和 参数 
>
> 4.配置察看结果树,聚合报告,断言

### 8.3 参数化

> 参数化:是自动化测试脚本的一种常用技巧.就是将脚本中某些输入赋值给一个变量,在脚本运行时就调用这个变量值作为 输入,这个过程就是参数化. 
>
> 参数化方法: 
>
> `1.用户定义的变量 `
>
> `2.csv数据文件设置 `
>
> 变量调用的方法: `${变量名}`

#### 8.3.1 用户定义的变量

> `作用`:一般用来做`全局变量` 
>
> 位置:线程组--添加--配置元件 --用户定义的变量 

#### 8.3.2 CSV数据文件设置

> `作用`:一般用来实现读取`大量数据`. 
>
> CSV数据文件设置内容: 
>
> --**文件名**:配置文件路径和文件名,可以通过浏览选择 
>
> --**文件编码**:一般默认utf-8 
>
> --**变量名称**:对应参数文件中每列的变量名,也是要引用到取样器中的参数变量名.多个变量名之间用英文逗号隔							开. 
>
> --**忽略首行**:选择true,从文件的第二行开始读取 
>
> ​							选择false,从文件的第一行开始读取 
>
> --**是否允许带引号**:选择true,允许数据中带引号,一般指双引号. 
>
> ​							选择false,不允许数据中带引号. 
>
> ​							比如文件内容为"abc",选择true,读取到的是abc,选择false,读取到的是"abc" 
>
> --**遇到文件结束符再次循环**:选择true,读取到文件的最后一行后循环从头开始读取 
>
> ​							选择false,读取到文件的最后一行后,停止读取文件 
>
> --**遇到文件结束符结束线程**:选择true,读取到文件的最后一行后,结束运行线程. 
>
> ​							选择false,读取到文件的最后一行后,继续运行线程.

### 8.4 关联

> 关联:将上下两个脚本关联起来. 
>
> `关联方法`: 
>
> 1.`自动关联`:`http cookie 管理器 `
>
> 2.`手动关联`:`正则表达式提取器 `

#### 8.4.1 自动关联

> `作用`:http cookie管理器会自动将上一个脚本产生的cookie保存,并在后来所有需要使用到该cookie的取样器中使用这个cookie的值.

#### 8.4.2 手动关联

> `手动关联`:通过正则表达式提取器,将上一个请求的响应数据中的某个数据提取出来,当做参数传递给下一个请求使用. 
>
> 
>
> `正则表达式`:可以理解为通过一个表达式,从较多数据中匹配出具有某些特征的数据.匹配出来的内容用()括起来 
>
> 
>
> 正则表达式用法: 
>
> 1.`分析待提取内容的特征 `
>
> 2.`通过前后位置做出限定 `
>
> 
>
> `正则表达式语法: `
>
> [a-z] :匹配a-z的任意一个小写字母 
>
> [A-Z] :匹配A-Z的任意一个大写字母 
>
> [0-9] :匹配0-9的任意一个数字,等同于\d 
>
> 
>
> \w :匹配任意一个字符(字母,数字,汉字,下划线_) 
>
> . :匹配除了换行符以外的任意一个字符,包含特殊符号 
>
> {n} :表示匹配前面的表达式n个 
>
> {m,n} :表示匹配前面的表达式m至n个,优先匹配n个 m<n 
>
> 
>
> \+:表示匹配前面的表达式1次或者多次,最少1次 
>
> ? :表示匹配前面的表达式1次或者0次,最多1次 
>
> \* :表示匹配前面的表达式任意次数,可以是1次,可以是0次,也可以是多次 
>
> 
>
> \s :表示匹配一个空格 
>
> ^ :表示匹配一行的开始,即行首 
>
> $ :表示匹配一行的结束,即行尾 
>
> \ :转义符,将具有特殊含义的符号的含义去掉 

> `正则表达式提取器内容: `
>
> --引用名称:定义变量名,方便后面的请求中使用 
>
> --正则表达式:可以提取出目标数据的正则表达式 
>
> --模板:表示从哪个表达式中提取内容,用 $数字$ 表示,$1$ 表示从第一个表达式中引用数据 
>
> --匹配数字:表示从模板数据中取第几个值,0表示随机取值,-1表示全部取值,1表示取第一个 

#### 8.4.3 文件上传

> 1.通过抓包获取上传文件参数 
>
> 2.在取样器--上传文件 中配置数据: 
>
> --`文件名称`:要上传的文件的路径+名称,可以通过浏览选择 
>
> --`参数名称`:上传文件这个操作的参数名称 
>
> --`MIME类型`:上传文件的类型,不同文件类型不同

### 8.5 debug sampler

> `作用`:用来打印变量的值,帮助调试脚本 
>
> 位置:线程组--添加--取样器--debug sampler 

### 8.6 逻辑控制器

#### 8.6.1 if逻辑控制器

> if控制器:条件判断控制器.根据条件判断是否执行对应的操作.根据给定的表达式的值决定是否执行该控制器下的取样 器.
>
> 一般使用内置函数 `${__groovy("实际结果"=="预期结果")} `进行判断. 
>
> 或者直接写成: `${__groovy("${变量名}"=="预期结果")}`

#### 8.6.2 foreach控制器

> foreach控制器:一般和`用户定义的变量`一起使用,其在用户定义的变量中读取一系列相关的变量,每读取一个变量,该控 制器下的取样器就会被执行一次或者多次,每次读取不同的变量. 
>
> foreach 控制器的内容: 
>
> --`输入变量前缀`:开始循环读取的字段,对应用户定义的变量中变量的前部分 
>
> --`开始循环字段:`开始循环读取的字段,不包含输入的数值 
>
> --`结束循环字段`:循环结束的字段,包含输入的数值 
>
> --`输出变量名称`:定义一个变量名,从用户定义的变量中循环读取出来的值赋值给这个变量,作为控制器下取样器的输入 
>
> --`add "_" before number:`允许变量名称中在数字前面加上_ 

#### 8.6.3 switch 控制器

> Switch控制器:开关控制器,根据某些规则在选择控制器下的对应的不同取样器进行操作。switch value的值可以为数 字、字符串、变量等等。控制器下的子取样器按照索引方式取值，从0开始。 
>
> 
>
> `主要有两种方法`：
>
> 1、通过数值控制需要执行的取样器，0表示第一个 
>
> 2、通过名称控制需要执行的取样器，取样器名称与value值一致则执行 
>
> 
>
> `生成随机数`: 
>
> jmeter选项--函数助手对话框---选择 random(随机数函数) 
>
> --一个范围内最小值:生成随机数的最小值 
>
> --一个范围内允许最大值:生成随机数的最大值 
>
> --Name of variable in which to store the result (optional):定义变量名,将函数生成的值赋值给变量 

#### 8.6.4 loop控制器

> loop控制器:`循环控制器`.根据数字控制循环的次数. 

## 9 并发数计算

> 1.并发数:一般来源于需求规格说明书,如果规格说明书没有,则根据经验估算: 
>
> 
>
> 2.`跟并发数有关的因素: `
>
> a.系统用户数(已经注册的用户) 
>
> b.在线用户数 
>
> c.并发用户数(一般是指平均并发用户数) 
>
> d.峰值并发用户数 
>
> 
>
> 3.并发数计算公式： 
>
> 1）平均并发用户数为` C = nL/T` 或者 `平均并发用户数=n x【8%~15%】 `
>
> 2）并发用户数峰值` C‘ = C + 3*根号C `
>
> `n`:在线用户数(日活量) 
>
> `L`:登录用户的平均时长 
>
> `T`:考察的时间长度 
>
> `C'`:峰值并发用户数 '

![image-20200810153600335](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200810153600335.png)

![image-20200810153625885](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200810153625885.png)

## 10 性能指标

| 性能指标 | 条件                   | 结果             |
| -------- | ---------------------- | ---------------- |
| 吞吐量   | \>=期望值<br /><期望值 | 通过<br/>不通过  |
| 响应时间 | <=5秒<br />>5秒        | 通过<br />不通过 |
| 错误率   | <=1%<br />>1%          | 通过<br />不通过 |
| CPU      | <=80%<br />>80%        | 通过<br />不通过 |
| 内存     | <=80%<br />>80%        | 通过<br />不通过 |
| 网络     | <=50%<br />>50%        | 通过<br />不通过 |

## 11 资源监控

### 11.1 安装Server Agent

> Server Agent:服务器代理,服务器所有接受和发送的数据都会经过Server Agent,从而很好的模拟出服务器的状态. 
>
> 
>
> 安装步骤: 
>
> 1.找到server agent的安装包解压 
>
> 2.进入解压出来的文件夹,找到startAgent.bat,双击启动

### 11.2 安装资源监控插件

> 1.找到资源监控插件包 
>
> 2.将其复制到jmeter的lib/ext目录下 
>
> 3.重启jmeter,进入选项--plugin manager--available plugins --选择最下面的jpgc standard set --点击右 
>
> 下角的apply changes and restart jmeter 
>
> 4.等待jmeter安装后重启 

### 11.3 资源监控数据采集

> 1.在添加 线程组--添加--监听器--jp@gc-PerfMon Metrics Collector 
>
> 2.在 server to monitor中配置 要监听的服务器的ip,端口,要采集的指标(CPU,内存等) 
>
> 3.运行脚本 

## 12 实战演练

### 12.1 操作步骤

> 1.业务学习 
>
> 2.需求分析:注册 登录 浏览商品 加入购物车 支付 查看订单 退款 
>
> 3.设计模型: ---以注册为例 
>
> 测试类型:压力测试 
>
> 并发数: 注册 200 (登录 300 浏览商品 500 加入购物车300 支付250 查看订单300 退款300) 
>
> 
>
> 起始并发:100 
>
> 第一次并发:100 
>
> 第二次并发:120 步长20 
>
> 第三次并发:150 步长30 
>
> 
>
> --查看各项指标变化,是否明显,是否接近预期标准, 
>
> 如果是,则减少步长:第四次并发:170 步长20 
>
> 如果不是,继续增加步长,第四次并发:190 步长40...... 

> 1.用例标题:ecshop 200个用户注册压力测试 
>
> 2.测试环境: 
>
> 操作系统:windows7 
>
> 硬件设施:Intel(R) Core(TM) i5-3230M cpu@2.6GHz 2.59GHz 6M 
>
> 内存:2G 
>
> 服务器:apache**12.2** 结果分析
>
> DB服务器:mysql 
>
> 
>
> 3.预置条件: 
>
> 系统已经启动,网络服务正常 
>
> 用户数据准备ok,数据保存在csv文件中 
>
> 性能测试工具jmeter运行良好 
>
> 
>
> 4.操作步骤: 
>
> 编写单个用户注册的脚本,并调试ok 
>
> 对脚本进行增强--参数化,添加csv文件,配置完成 
>
> 对脚本增强--添加察看结果树,聚合报告,断言 
>
> 设置线程组中的线程数 
>
> 启动服务器代理,添加资源监控插件,配置要监控的服务器IP,端口,监控的指标 
>
> 
>
> 5.预期结果 
>
> 吞吐量大于等于200/5=40/s 
>
> 响应时间小于等于5s 
>
> CPU 和内存占比不能超过80% 
>
> 网络占有率小于等于50% 
>
> 错误率小于等于1% 

### 12.2 结果分析

> 性能分析两个方向: 
>
> `1.硬件:CPU ,内存,磁盘,带宽(网络) `
>
> `2.软件:代码 算法 `
>
> 
>
> `如何分析性能测试数据? `
>
> 1.看聚合报告数据: 
>
> 是否有错误率 
>
> 看响应时间:平均时间,50% 90% 95% 99% 最小值 最大值 
>
> 看吞吐量是否达到预期 
>
> 2.资源监控插件中的数据: 
>
> 数据的波动是否很大 
>
> 指标的取值是否在预期范围内 

### 12.3 性能调优

> 性能调优:就是用更好的资源提供更好的服务,达到成本利益最大化. 
>
> 方法: 
>
> 1.硬件:`更换更好的硬件设施 `
>
> 2.软件: 
>
> `数据库调优:SQL语句优化,分区存储,创建索引,读写分离 `
>
> `使用负载均衡技术---算法 `
>
> `使用分布式部署 `
>
> `使用缓存技术:通过缓存减少读写压力`

## 13 脚本出错如何排查

> 1.看一下聚合报告里面出错的取样器是哪一个 
>
> 
>
> 2.查找该取样器的结果树的内容: 
>
> 看取样器结果 
>
> 看响应数据,如果响应数据正确,断言问题 ---无法识别的可以用html网页查看报错 
>
> 如果响应数据错误,请求出错 
>
> 看请求数据:URL(ip,路径),方法,参数 
>
> 
>
> 3.如果请求没有问题,可能是环境没有启动,服务器问题 
>
> 4.查看jmeter的日志,搜索关键字,比如error, fail , timeout , connectedrefused ,no http response